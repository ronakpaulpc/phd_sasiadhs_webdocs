---
title: "NPDHS data pooling pre-checks"
---

# Getting started

Here we show the pre-requisite code sections. Run these at the outset to avoid errors. First we load the required packages.

```{r}
#| label: load-packages
#| echo: true
#| output: false

easypackages::libraries(
  # Data i/o
  "here",                 # relative file path
  "rio",                  # file import-export
  
  # Data manipulation
  "janitor",              # data cleaning fns
  "haven",                # stata, sas, spss data io
  "labelled",             # var labelling
  "readxl",               # excel sheets
  # "scales",               # to change formats and units
  "skimr",                # quick data summary
  "broom",                # view model results
  
  # Data analysis
  "DHS.rates",            # demographic rates for dhs-like surveys
  "GeneralOaxaca",        # BO decomposition for non-linear
  "survey",               # apply survey weights
  
  # Analysis output
  "gt",
  # "modelsummary",          # output summary tables
  "gtsummary",            # output summary tables
  "flextable",            # creating tables from objects
  "officer",              # editing in office docs
  
  # R graph related packages
  "ggstats",
  "RColorBrewer",
  # "scales",
  "patchwork",
  
  # Misc packages
  "tidyverse",            # Data manipulation iron man
  "tictoc"                # Code timing
)

```

Next we turn off scientific notations.

```{r}
#| label: turn-off-scientific-notation
#| echo: true
#| output: false

options(scipen = 999)

```

Next we set the default gtsummary print engine for tables.

```{r}
#| label: set-gtsummary-default
#| echo: true
#| output: false 

theme_gtsummary_printer(print_engine = "flextable")

```

Now we set the flextable output defaults.

```{r}
#| label: set-flextable-default
#| echo: true
#| output: false 

set_flextable_defaults(
  font.size = 11,
  text.align = "left",
  big.mark = "",
  background.color = "white",
  table.layout = "autofit",
  theme_fun = theme_vanilla
)

```

# Document introduction

Here we document the variable codes and labels of variables across all the Nepal Demographic and Health Survey (DHS) datasets. We check the variable labels and codes before running the pooling code in "daprep-v01_npdhs.R". We pool the following Nepal DHS surveys:

```{r}
#| label: data-import-temp
#| echo: false
#| output: false

# Here we temporarily import the tibbles for sample size table creation
# Importing the npbr nested tibble
npbr1_tmp_intro <- read_rds(
  file = here("website_data", "npbr1_nest0.rds")
)
# Importing the npir nested tibble
npir1_tmp_intro <- read_rds(
  file = here("website_data", "npir1_nest0.rds")
)
# Importing the nphr nested tibble
nphr1_tmp_intro <- read_rds(
  file = here("website_data", "nphr1_nest0.rds")
)
# Importing the nppr nested tibble
nppr1_tmp_intro <- read_rds(
  file = here("website_data", "nppr1_nest0.rds")
)

```

```{r}
#| label: tbl-detail-survey-rounds
#| echo: true
#| output: true
#| tbl-cap: "Nepal DHS datasets and their sample size to be used for pooling"

# Creating the table of surveys to be used for pooling
npbr1_tmp_intro |> 
  mutate(n_births = prettyNum(n_births, big.mark = ",")) |> 
  select(c(ctr_name, svy_year, n_births)) |> 
  # Join vars from npir_tmp_intro
  left_join(
    npir1_tmp_intro |> 
      mutate(n_women = prettyNum(n_women, big.mark = ",")) |> 
      select(c(year, n_women)),
    by = join_by(svy_year == year)
  ) |> 
  # Join vars from nphr_tmp_intro
  left_join(
    nphr1_tmp_intro |> 
      mutate(n_households = prettyNum(n_households, big.mark = ",")) |> 
      select(svy_year, n_households),
    by = join_by(svy_year)
  ) |> 
  # Join vars from nppr_tmp_intro
  left_join(
    nppr1_tmp_intro |> 
      mutate(n_persons = prettyNum(n_persons, big.mark = ",")) |> 
      select(svy_year, n_persons),
    by = join_by(svy_year)
  ) |> 
  # convert nested tibble to simple tibble
  unnest(cols = c()) |> 
  mutate(
    ccode = row_number(), 
    .before = ctr_name
  ) |> 
  # convert to flextable object
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

```{r}
#| label: just-another-chunk01
#| echo: false
#| output: false

# We remove the (.)_tmp_intro nested tibbles from the environment as they are not 
# required further
rm(list = c("npbr1_tmp_intro", 
            "npir1_tmp_intro", 
            "nphr1_tmp_intro", 
            "nppr1_tmp_intro"))

# Reclaim unused space
gc()

```

We use the following variables for the pooled data analysis:

-   **Dependent variable**
    -   infantd = Index child died during infancy period (0-11 months)
-   **Main Independent variable**
    -   sibsurv_nmv = Survival status of preceding child (Death scarring)
    -   binterval_3c_nmv_opp = Birth interval preceding to index child
-   **Independent variables \[CHILD LEVEL\]**
    -   cyob10y_opp = Birth cohort of index child
    -   bord_c = Birth order of index child
    -   sex_fm = Sex of index child
    -   season = Season during birth
-   **Independent variables \[MOTHER/PARENT LEVEL\]**
    -   ~~myob_opp = Birth cohort of mother~~
    -   macb_c_opp = Mother's age during birth of index child
    -   medu_opp = Mother's Level of education
    -   fedu_opp = Father's level of education
-   **Independent variables \[HOUSEHOLD LEVEL\]**
    -   religion = Religion
    -   nat_lang = Native language of respondent
    -   wi_qt_opp = Household wealth quintile
    -   ~~hhgen_2c_opp = Generations in household~~
    -   hhstruc_opp = Household structure
    -   head_sex_fm = Sex of HH head
-   **Independent variables \[COMMUNITY LEVEL\]**
    -   por = Place of residence of the household
    -   ecoreg = Ecological region

*Note: (a) Crossed names indicates variable not included.*

# Data import

We will directly import the nested tibble here. The code for dataset preparation is in the "daprep-v01_npdhs.R" script file.

```{r}
#| label: data-import
#| echo: true
#| output: true

# Here we import the tibbles to be used for dataset checking
# Import the npbr nested tibble
npbr1_pre_tmp0 <- read_rds(file = here("website_data", "npbr1_nest0.rds"))
# Import the nphr nested tibble
nphr1_pre_tmp0 <- read_rds(file = here("website_data", "nphr1_nest0.rds"))
# Import the nppr nested tibble
nppr1_pre_tmp0 <- read_rds(file = here("website_data", "nppr1_nest0.rds"))

```

# Nepal BR dataset use for variable creation

## Checking the Women's weight variable before harmonization

We will check the formatting of the v005 women's weight variable before creating the pooled survey weight. For this we will use the labelled::look_for().

```{r}
#| label: create-dict-v005
#| echo: true
#| output: false

# First we create the data dictionary of v005 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v005 = map(npbr_data, \(df) {
    df |> 
      select(v005) |> 
      look_for(details = "full") |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character() |> 
      select(-c(levels:n_na))
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v005
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v005 variable across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v005)) |> 
  select(-pos) 
# Convert and view the tibble as flextable
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The women's weight variables are in numeric class and have no missing values. Therefore, we need not reformat them. Hence we directly use it for preparing the pooled survey weight. **NOTE that,** the women's weight for the Nepal 1996, 2001 and 2011 rounds have few unique values. This could be because there might have been fewer sampling units in the secondary stage.

## Checking the ID variables before harmonization

Here we check the formatting of the variables using which we will prepare the ID variables for the pooled Nepal birth history recode (BR) dataset. We will use the following constituent variables for creating the ID variables for the pooled dataset:

```{r}
#| label: create-dict-npbr-idvars
#| echo: true
#| output: false

# We check the var type of ID vars in all npbr datasets.
# First we create a data dictionary of the npbr datasets in nested tibble.
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |>
  mutate(lookfor_idvars = map(npbr_data, \(df) {
    df |> 
      select(v001, v002, v003, bord, v021, v022, v023, v024) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-npbr-idvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of variables to be used for ID creation across the npbr rounds"

# Now we unnest the tibble and output the pooled data dictionary 
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_idvars)) |> 
  arrange(pos)

# Convert and view the tibble as flextable
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above we can see that v023 and v024 are of labelled class, while the rest are in numeric class. Therefore, we will check the numeric and labelled variables in different ways. **Note that** although survey year is a constituent ID variable we have not checked it. It is imperative that survey year would be a 4-digit variable.

### Numeric ID variables check

First, let's find out the required length of the numeric ID variables by checking the maximum values of the constituent ID variable across the Nepal DHS datasets. Here we estimate the summary stats of numeric constituent variables using skim_without_charts().

```{r}
#| label: create-dict-numeric-idvars
#| echo: true
#| output: false

# Check the summary stats for ID vars using skimr in each npbr dataset.
# First we estimate the summary stats using skim_without_charts().
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(skim_id_num = map(npbr_data, function(df) {
    df |> 
      select(v001, v002, v003, bord, v021, v022) |> 
      skim_without_charts() |> 
      as_tibble() |> 
      select(-c(skim_type, n_missing, complete_rate)) |> 
      rename(
        variable = 1,
        mean = 2,
        sd = 3,
        min = 4,
        p25 = 5,
        p50 = 6,
        p75 = 7,
        max = 8
      )
  }))
npbr1_pre_tmp1

```

Next, we check the summary stats of numeric variables by variable name-wise.

```{r}
#| label: tbl-dict-numeric-idvars
#| echo: true
#| output: true
#| tbl-cap: "Summary statistics of the numeric ID variables"

# Now we unnest the nested tibble so that we can compare the variable length 
# across the npbr datasets.
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(skim_id_num)) |> 
  arrange(variable, svy_year) |> 
  # change the decimal places of selected variables
  mutate(
    mean = sprintf("%.1f", mean),
    sd = sprintf("%.1f", sd),
    p75 = sprintf("%.0f", p75)
  )
# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

Now we find out the required length of the numeric ID variables to be set, so that we can correctly concatenate them to create the ID variables. The **required length of the numeric ID variables** are given in **max_digits** column. **Note that** survey year is also a constituent ID variable of 4-digits.

```{r}
#| label: tbl-maxlen-numeric-idvars
#| echo: true
#| output: true
#| tbl-cap: "The maximum length of numeric variables to be set across the npbr rounds for concatenating the ID variables"

# Processing the above nested tibble further
npbr1_pre_tmp3 <- npbr1_pre_tmp2 |> 
  group_by(variable) |> 
  # find the minimum and maximum values across surveys 
  summarize(
    min_val = min(min),
    max_val = max(max)
  ) |> 
  mutate(
    # calculate the num of digits in the maximum values
    max_digits = nchar(as.character(max_val)),
    # convert char var to factor
    variable = fct(
      variable, 
      levels = c("v001", "v002", "v003", "bord", "v021", "v022")
    )
  ) |> 
  # sort the rows by factor levels 
  arrange(variable) |> 
  # add variable labels and relocate it after variable name.
  bind_cols(vlabel = c("cluster number", "household number", 
                       "respondent's line number", "birth order", 
                       "primary sampling unit", "sample strata for se")) |> 
  relocate(vlabel, .after = 1)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp3 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

### Labelled ID variables check

First we check the labels in sub-national region variable coded as v024 across the npbr datasets. Let's create a nested tibble of v024's value labels.

```{r}
#| label: create-dict-v024
#| echo: true
#| output: false

# Create the data dictionary for v024 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v024 = map(npbr_data, \(df) {
    df |> 
      select(v024) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

Now we view the value labels of v024 in the table below.

```{r}
#| label: tbl-dict-v024
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v024 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v024)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |> 
  # Show the variable name in a col
  mutate(var_name = "v024", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

**NOTE:** The sub-national region var, v024 has different label values in each survey year. It was same for npbr 1996, 2001 and 2006. After that the label values are different for each survey round.\
**VERD:** In this analysis, we do not use the region var in the ID var.

------------------------------------------------------------------------

Secondly, we check the labels in v023 variable that denotes the stratifications used for sampling design. First we create a nested tibble of v023's value labels.

```{r}
#| label: create-dict-v023
#| echo: true
#| output: false

# Create the data dictionary for v023 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v023 = map(npbr_data, \(df) {
    df |> 
      select(v023) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

Now we view the value labels of v023 in the table below.

```{r}
#| label: tbl-dict-v023
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v023 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v023)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v023", .before = 2) 

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

**NOTE:** The labels of v023 are different across the survey rounds.\
**VERD:** Therefore we cannot use v023 in the ID variable preparation.

Altly, we can use the ecological region variable (secoreg) in the ID var. We will check for this in future.

## Checking the Birth History variables before harmonization

Undoubtedly the birth history variables are important for this study objective. Therefore, we need to scrutinize all the birth history variables before using them to prepare harmonized variables for the pooled dataset.

```{r}
#| label: create-dict-bhvars
#| echo: true
#| output: false

# We check the birth history vars in all npbr datasets.
# First we create a data dictionary in nested tibble.
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |>
  mutate(lookfor_bhvars = map(npbr_data, \(df) {
    df |> 
      select(bidx, matches("^b[0-9]+")) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-bhvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of birth history variables across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_bhvars)) |> 
  arrange(pos)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above table we get an overall snapshot of the birth history variables. We see that the variables b1-b13 are common in all the six npbr datasets. Notably npbr 2001 and 2006 have some extra variables that are not available in other rounds. Next, we look at the other labelled variables which are common across npbr in more details. We would like to see if the value labels of the common birth history variables are similar across the npbr datasets.

### b0 - child is twin

We check the value labels of b0 variable that denotes whether the child is twin. First we create a nested tibble of b0's value labels.

```{r}
#| label: create-dict-b0
#| echo: true
#| output: false

# Create the data dictionary for b0 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_b0 = map(npbr_data, \(df) {
    df |> 
      select(b0) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b0
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b0 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b0)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b0", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see the value labels of b0 in the above table. We see that the value labels are same across all the npbr datasets.

### b1 - month of birth

We see that the b1 variable has value labels only for npbr 2011. Therefore, we check the value labels of the variable during this round.

```{r}
#| label: tbl-dict-b1
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b1 in npbr 2011"

# Create the data dictionary for b1 in npbr 2011
npbr1_pre_tmp0$npbr_data$npbr_2011 |> 
  select(b1) |> 
  look_for(details = "full") |> 
  lookfor_to_long_format() |> 
  convert_list_columns_to_character() |> 
  select(-c(pos, levels, class:n_na)) |> 
  qflextable() |> 
  autofit()

```

**Note that** the birth months correspond to months in hindu calendar. The days of months do not correspond to the english calendar and this creates a problem when we will prepare the season during birth variable, later.

**SOL:** We can re-create the birth month variable from b3 - child's dob (in cmc) by dividing b3 by 12 and taking the remainder as birth month.

### b4 - sex of child

We check the value labels of b4 variable which gives the sex of the child. First we create a nested tibble of b4's value labels.

```{r}
#| label: create-dict-b4
#| echo: true
#| output: false

# Create the data dictionary for b4 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_b4 = map(npbr_data, \(df) {
    df |> 
      select(b4) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b4
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b4 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b4)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b4", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see the value labels of b4 in the above table. The value labels are same across all the npbr datasets.

### b5 - child is alive

We check the value labels of b5 variable which gives the survival status of the child. First we create a nested tibble of b5's value labels.

```{r}
#| label: create-dict-b5
#| echo: true
#| output: false

# Create the data dictionary for b5 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_b5 = map(npbr_data, \(df) {
    df |> 
      select(b5) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b5
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b5 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b5)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b5", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that the value labels of survival status of child are same across all the npbr datasets.

### b6 - age at death

We check the value labels of b6 variable which shows the age at death of children. Note that this variable has many missing values across all npbr rounds as not all children experienced mortality throughout their lifetime. First we create a nested tibble of b6's value labels.

```{r}
#| label: create-dict-b6
#| echo: true
#| output: false

# Create the data dictionary for b5 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_b6 = map(npbr_data, \(df) {
    df |> 
      select(b6) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b6
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b6 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b6)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b6", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that the value labels of age at death of child are in two groups. First, they are same for npbr 1996, 2001 and 2006 and and then for npbr 2011, 2016 and 2022.

### b9 - child lives with whom

We check the value labels of b9 variable which gives info on who the child lives with. First we create a nested tibble of b9's value labels.

```{r}
#| label: create-dict-b9
#| echo: true
#| output: false

# Create the data dictionary for b9 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_b9 = map(npbr_data, \(df) {
    df |> 
      select(b9) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b9
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b9 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b9)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b9", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see in the above table that the value labels of b9 are same across all the npbr datasets.

### b10 - completeness of information

We check the value labels of b10 variable which gives the completeness of birth history information. First we create a nested tibble of b10's value labels.

```{r}
#| label: create-dict-b10
#| echo: true
#| output: false

# Create the data dictionary for b10 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_b10 = map(npbr_data, \(df) {
    df |> 
      select(b10) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b10
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b10 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b10)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b10", .before = 2) 

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |>
  align(align = "left", part = "all") |> 
  autofit()

```

We can see in the above table that the value labels of b10 are same across npbr 1996, 2001, 2006 and 2011 datasets. Then they are same for npbr 2016 and 2022.

## Checking the Common independent variables before harmonization

Next we start documenting the common independent variables. First we will check the data dictionary of the common independent variables. Then we will check them variable wise.

```{r}
#| label: create-dict-comindvars
#| echo: true
#| output: false

# We check the common independent vars in all npbr datasets.
# First we create the data dictionary in nested tibble.
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |>
  mutate(lookfor_comindvars = map(npbr_data, \(df) {
    df |> 
      # select the common independent variables
      select(v106, v011, v501, v701, v025, v151, v152) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-comindvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of common independent variables across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_comindvars)) |> 
  arrange(pos)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above table we get an overall snapshot of the common independent variables. We see that majority of the have different number of value labels across the six npbr datasets. Only v025 and v151 have the same number of value labels across npbr rounds. Next, we look at the labelled variables among these common variables in more details. We would like to see if the value labels and codes of the common independent variables are similar across the npbr datasets.

### v106 - Mother's education level

We check the value labels of v106 variable that denotes the highest education level of mother. First we create a nested tibble of v106's value labels.

```{r}
#| label: create-dict-v106
#| echo: true
#| output: false

# Create the data dictionary for v106 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v106 = map(npbr_data, \(df) {
    df |> 
      select(v106) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v106
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v106 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v106)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v106", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see the value labels of v106 are mostly similar except for npbr 1996 and 2011 datasets.

### v011 - Date of birth (in CMC)

The v011 variable, which has the dob of mothers in cmc, is a numeric variable. Let's check the range of these values in further details such as checking for outliers. First let's create a nested tibble of the summary statistics of v011 variable.

```{r}
#| label: create-dict-v011
#| echo: true
#| output: false

# Create the summary statistics for v011 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(skim_v011 = map(npbr_data, \(df) {
    df |> 
      select(v011) |> 
      skim_without_charts() |> 
      as_tibble() |> 
      select(-c(skim_type, complete_rate)) |> 
      rename(
        variable = 1,
        n_miss = 2,
        mean = 3,
        sd = 4,
        min = 5,
        p25 = 6,
        p50 = 7,
        p75 = 8,
        max = 9
      )
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v011
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v011 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(skim_v011)) |> 
  # Make variable values have one decimal point 
  mutate(
    mean = sprintf("%.1f", mean),
    sd = sprintf("%.1f", sd)
  )

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

### v501 - Mother's marital status

We check the value labels of v501 variable which gives the current marital status of mother. First we create a nested tibble of v501's value labels.

```{r}
#| label: create-dict-v501
#| echo: true
#| output: false

# Create the data dictionary for v501 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v501 = map(npbr_data, \(df) {
    df |> 
      select(v501) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v501
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v501 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v501)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v501", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

All the npbr rounds have 5 value labels. The npbr 1996, 2001 and 2006 rounds have a set of similar value label texts. Then npbr 2011, 2016 and 2022 have another set of similar value labels.

### v701 - Husband/Partner's education level

We check the value labels of v701 variable which gives the current marital status of mother. First we create a nested tibble of v701's value labels.

```{r}
#| label: create-dict-v701
#| echo: true
#| output: false

# Create the data dictionary for v701 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v701 = map(npbr_data,
                            \(df) {
                              df |> 
                                select(v701) |> 
                                look_for() |> 
                                lookfor_to_long_format() |> 
                                select(value_labels)
                            }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v701
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v701 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v701)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v701", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

All the npbr rounds have 5 value labels. The npbr 1996, 2001 and 2006 rounds and npbr 2011, 2016 and 2022 have a similar set of value labels with a difference in wording among them.

### v025 - Type of place of residence

We check the value labels of v025 variable which shows if a household belongs to rural or urban psu. First we create a nested tibble of v025's value labels.

```{r}
#| label: create-dict-v025
#| echo: true
#| output: false

# Create the data dictionary for v025 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v025 = map(npbr_data, \(df) {
    df |> 
      select(v025) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v025
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v025 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_v025)) |> 
  unnest(cols = c(lookfor_v025)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v025", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The values labels and codes for v025 are same across all the npbr rounds.

### v151 - Sex of household head

We check the value labels of v151 variable which gives the sex of the household head. First we create a nested tibble of v151's value labels.

```{r}
#| label: create-dict-v151
#| echo: true
#| output: false

# Create the data dictionary for v151 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v151 = map(npbr_data, \(df) {
    df |> 
      select(v151) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v151
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v151 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v151)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v151", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The values labels and codes for v151 are same across all the npbr rounds.

### v152 - Age of household head

Interestingly, we see v152 (a continuous variable) has value labels for all rounds except npbr 1996. Therefore, we check the value labels of v152 for those rounds. First we create a nested tibble of v152's value labels.

```{r}
#| label: create-dict-v152
#| echo: true
#| output: false

# Create the data dictionary for v152 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  filter(svy_year != 1996) |> 
  mutate(lookfor_v152 = map(npbr_data, \(df) {
    df |> 
      select(v152) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v152
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v152 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v152)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v152", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see that the value labels of v152 are mostly for missing values. However, since v152 has no missing values across the npbr rounds, we need not be concerned about them.

## Checking the Social group variables before harmonization

Now we document the social group variables and then harmonize them. Upon manually checking the full data dictionaries of each npbr dataset we find the following variables - religion, ethnicity, and, native language. First we will check the data dictionary of these social group variables. Then we will check them variable wise.

```{r}
#| label: create-dict-socgrp
#| echo: true
#| output: false

# We check the social group vars in all npbr datasets.
# First we create the data dictionary in nested tibble.
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |>
  mutate(lookfor_socgrp = map(npbr_data, \(df) {
    df |> 
      # select the social group variables
      select(
        v130, v131, 
        matches("slang[nr]|snlang|slnative|v045c")
      ) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-socgrp
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of social group variables across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_socgrp)) |> 
  arrange(pos)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table gives an overall snapshot of the social group variables. All the variables are of labelled class across all the npbr datasets. We see that all the variables have different number of value labels across the six npbr datasets. **Note that**, the religion and native language of respondent variable has some missing values in the npbr 1996 dataset. Next, we look at the variables individually for matching the value labels across the npbr datasets.

### v130 - Religion of hh head

We check the value labels of the first social group variable v130, which gives the religion of household head. First we create a nested tibble of v130's value labels.

```{r}
#| label: create-dict-v130
#| echo: true
#| output: false

# Create the data dictionary for v130 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v130 = map(npbr_data, \(df) {
    df |> 
      select(v130) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v130
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v130 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v130)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v130", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

Evidently, the values labels and codes for v130 are different across all the npbr rounds. Only the first three value labels "hindu", "buddhist" and "muslim" and their label codes are same across all the npbr rounds. Therefore, we will work with these labels for harmonization. <br>**NOTE:** The labels "christian" and "other" are also present but their label codes vary across the npbr rounds.

### v131 - Ethnicity of hh head

Next, we check the value labels of the v131 variable, which gives the ethnicity of household head. First we create a nested tibble of v131's value labels.

```{r}
#| label: create-dict-v131
#| echo: true
#| output: false

# Create the data dictionary for v131 in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_v131 = map(npbr_data, \(df) {
    df |> 
      select(v131) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v131
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v131 across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v131)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v131", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

Similar to v130, the values labels and codes for v131 are different across all the npbr rounds. Notably, npbr 2001 and 2006 have more than 60 ethnicity categories. Unfortunately, we do not know how to group these categories. Therefore, we might not use this variable as a social group characteristic.

### Native language of hh respondent

Next, we check the value labels of the native language of hh respondent variable. The variable names of this variable differs across the npbr datasets. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-natlang
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_lang = map(npbr_data, \(df) {
    df |> 
      select(matches("slang[nr]|snlang|slnative|v045c")) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-natlang
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of native language of respondent variable across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_lang)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "npbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "Native language", .before = 2)

# Convert the tibble to flextable for easy viewing
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The values labels are same for npbr 1996 and 2001, and then they vary for the other datasets. The value labels "nepali", "bhojpuri" and "maithili" are same across all the npbr rounds hut their labels code are different. Therefore, we will use these labels for harmonization.

## Correcting year-related variables

The year-related variables might have different formatting in each survey. Therefore, we need to check and harmonize them before appending the datasets.

```{r}
#| label: create-dict-yrvar
#| echo: true
#| output: false

# First we create the data dictionary of year-related vars in nested tibble
npbr1_pre_tmp1 <- npbr1_pre_tmp0 |> 
  mutate(lookfor_year = map(npbr_data, \(df) {
    df |> 
      select(c(b2, v007, v010)) |> 
      look_for(details = "full") |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character() |> 
      select(-c(levels:n_na))
  }))
npbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-yrvar
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of year-related variables across the npbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
npbr1_pre_tmp2 <- npbr1_pre_tmp1 |> 
  select(-c(unf, npbr_data, n_births)) |> 
  unnest(cols = c(lookfor_year)) |> 
  arrange(pos)
# Convert and view the tibble as flextable
npbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We find that none of the year variables have the correct values. Just look at the year of interview variable. We see that the year of interview values are higher than the corresponding survey years. Therefore, we need to reformat them before appending the datasets.

### v010 - Respondent's year of birth

We see that the v010 variable has some value labels only for npbr 2022. Therefore, we check those value labels for anything strange.

```{r}
#| label: tbl-dict-v010
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v010 in npbr 2022"

# Create the data dictionary for b1 in npbr 2011
npbr1_pre_tmp0$npbr_data$npbr_2022 |> 
  select(v010) |> 
  look_for(details = "full") |> 
  lookfor_to_long_format() |>
  convert_list_columns_to_character() |>
  select(-c(pos, levels, class:n_na)) |>
  qflextable() |> 
  autofit()

```

**Note that** there are two value labels that correspond to missing values. However as seen in @tbl-dict-yrvar, v010 has no missing values and those missing value labels would not have been used in the data. So we need not take further actions.

# Nepal HH dataset use for variable creation

## Checking the ID variables before harmonization

Here we check the formatting of the constituent variables with which we will prepare the ID variables for the pooled Nepal household recode (HR) dataset. We will use the following constituent variables for creating the ID variables for the pooled dataset:

```{r}
#| label: create-dict-nphr-idvars
#| echo: true
#| output: false

# We check the var type of ID vars in all nphr datasets.
# First we create a data dictionary of the nphr datasets in nested tibble.
nphr1_pre_tmp1 <- nphr1_pre_tmp0 |>
  mutate(lookfor_idvars = map(nphr_data, \(df) {
    df |> 
      select(hv001, hv002) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
nphr1_pre_tmp1

```

```{r}
#| label: tbl-dict-nphr-idvars
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of variables to be used for ID creation across the nphr rounds"

# Now we unnest the tibble and output the pooled data dictionary 
nphr1_pre_tmp2 <- nphr1_pre_tmp1 |> 
  select(c(ctr_name, svy_year, lookfor_idvars)) |> 
  unnest(cols = c(lookfor_idvars)) |> 
  arrange(pos)

# Convert and view the tibble as flextable
nphr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above we can see that both the hv001 and hv002 are of numeric class with no missing values. These variables can be used for preparing the ID variables after finding the maximum length of their largest value. **Note that** survey year is also a constituent ID variable of 4-digits and we need not check it.

```{r}
#| label: tbl-nphr-idvars-maxlen
#| echo: true
#| output: true
#| tbl-cap: "The maximum length of constituent ID variables to be set across the nphr rounds"

# We thought to process the above nested tibble further by decomposing the 
# "range" col into min and max values using separate_wider_regex().
# However, we hit a roadblock as pattern did not identify the max values in 
# some nphr rounds correctly
nphr1_pre_tmp3 <- nphr1_pre_tmp0 |> 
  # Generate the summary stats for id vars
  mutate(skim_idvars = map(nphr_data, \(df) {
    df |> 
      select(hv001, hv002) |> 
      skim_without_charts()
  })) |> 
  # Pool the summary stats for all nphr rounds
  select(c(ctr_name, svy_year, skim_idvars)) |> 
  unnest(cols = c(skim_idvars)) |> 
  arrange(skim_variable, svy_year) |> 
  # Group and generate the max and min values for each variable
  group_by(variable = skim_variable) |> 
  summarize(
    min_val = min(numeric.p0),
    max_val = max(numeric.p100)
  ) |> 
  # calculate the num of digits in the maximum values
  mutate(
    max_digits = nchar(as.character(max_val))
  ) |>
  # add variable labels and relocate it after variable name
  bind_cols(vlabel = c("cluster number", "household number")) |>
  relocate(vlabel, .after = 1)

# Convert the tibble to flextable for easy viewing
nphr1_pre_tmp3 |>
  qflextable() |>
  align(align = "left", part = "all") |>
  autofit()

```

The above table gives the required length of the constituent ID variables to be set, so that we can correctly concatenate them to create the ID variables. The **required length of the ID variables** are given in **max_digits** column. **Note that** survey year is also a constituent ID variable of 4-digits.

## Checking HH-level variables before harmonization

Here we check the ecological region and wealth quintile variables before harmonizing them. Note in Nepal 1996 and 2001 the wealth quintile variables are provided in separate datasets. Therefore we join those variables to the hh file before proceeding with the checking.

Upon manually checking the full data dictionaries we find the variable names. Now we will check the data dictionary of these hh-level variables. Then we will check their value labels variable wise.

```{r}
#| label: create-dict-hhvars
#| echo: true
#| output: false

# We check the hh-level vars in all nphr datasets.
# First we create the data dictionary in nested tibble.
nphr1_pre_tmp1 <- nphr1_pre_tmp0 |>
  mutate(lookfor_hhvars = map(nphr_data, \(df) {
    df |> 
      # select the common independent variables
      select(
        matches("^wlthind5$|^hv270$"), 
        matches("shez|shreg1|shecoreg")
      ) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
nphr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hhvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of hh-level variables across the nphr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
nphr1_pre_tmp2 <- nphr1_pre_tmp1 |> 
  select(c(svy_year, lookfor_hhvars)) |> 
  unnest(cols = c(lookfor_hhvars)) |> 
  arrange(pos, svy_year)

# Convert the tibble to flextable for easy viewing
nphr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table gives an overall snapshot of the hh-level variables. All the variables are of labelled class and have the same number of value labels across all the nphr datasets. **Note that**, the ecological region variable has a different value label code in the npbr 1996 dataset. Next, we compare the value labels of the variables across the nphr datasets.

### Ecological region variable

Next, we check the value labels of the native language of hh respondent variable. The variable names of this variable differs across the npbr datasets. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-ecoreg
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
nphr1_pre_tmp1 <- nphr1_pre_tmp0 |> 
  mutate(lookfor_ecoreg = map(nphr_data, \(df) {
    df |> 
      select(matches("shez|shreg1|shecoreg")) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
nphr1_pre_tmp1

```

```{r}
#| label: tbl-dict-ecoreg
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of ecological region variable across the nphr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
nphr1_pre_tmp2 <- nphr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_ecoreg)) |> 
  unnest(cols = c(lookfor_ecoreg)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "nphr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "Ecological region", .before = 2)

# Convert the tibble to flextable for easy viewing
nphr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

Clearly, the value label texts are same for all nphr rounds. However, the value label code is different in nphr 1996 (codes 0-2) when compared to the rest of nphr rounds (codes 1-2). Therefore, we need to be mindful of this during harmonization.

### Wealth index quintile variable

Next, we check the value labels of the household wealth quintile variable. The variable names of this variable differs across the npbr datasets. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-wiqt
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
nphr1_pre_tmp1 <- nphr1_pre_tmp0 |> 
  mutate(lookfor_wiqt = map(nphr_data, \(df) {
    df |> 
      select(matches("^wlthind5$|^hv270$")) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
nphr1_pre_tmp1

```

```{r}
#| label: tbl-dict-wiqt
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of wealth quintiles across the nphr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
nphr1_pre_tmp2 <- nphr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_wiqt)) |> 
  unnest(cols = c(lookfor_wiqt)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "nphr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "Wealth index quintiles", .before = 2)

# Convert the tibble to flextable for easy viewing
nphr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

Clearly, the value label codes are same in all nphr rounds. However, the value label texts are different in nphr 1996 and 2001, compared to the nphr 2006, 2011, 2016 and 2022 rounds. Therefore, we need to be mindful of this during harmonization.

# Nepal PR dataset use for family structure variables creation

## Checking the ID variables before harmonization

Here we check the formatting of the constituent variables with which we will prepare the ID variables for the pooled Nepal person recode (PR) dataset. We will use the following constituent variables for creating the ID variables for the pooled dataset:

```{r}
#| label: create-dict-nppr-idvars
#| echo: true
#| output: false

# We check the var type of ID vars in all nppr datasets.
# First we create a data dictionary of the nppr datasets in nested tibble.
nppr1_pre_tmp1 <- nppr1_pre_tmp0 |>
  mutate(lookfor_idvars = map(nppr_data, \(df) {
    df |> 
      select(hv001, hv002, hvidx) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
nppr1_pre_tmp1

```

```{r}
#| label: tbl-dict-nppr-idvars
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of variables to be used for ID creation across the nppr rounds"

# Now we unnest the tibble and output the pooled data dictionary 
nppr1_pre_tmp2 <- nppr1_pre_tmp1 |> 
  select(c(ctr_name, svy_year, lookfor_idvars)) |> 
  unnest(cols = c(lookfor_idvars)) |> 
  arrange(pos)

# Convert and view the tibble as flextable
nppr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above table we can see that all the three constituent ID variables are of numeric class with no missing values. These variables can directly be used for preparing the ID variables after finding the maximum length of their largest value. **Note that** survey year is also a constituent ID variable of 4-digits and we need not check it.

```{r}
#| label: tbl-nppr-idvars-maxlen
#| echo: true
#| output: true
#| tbl-cap: "The maximum length of constituent ID variables to be set across the nppr rounds"

# We thought to process the above nested tibble further by decomposing the 
# "range" col into min and max values using separate_wider_regex().
# However, we hit a roadblock as pattern did not identify the max values in 
# some nppr rounds correctly
nppr1_pre_tmp3 <- nppr1_pre_tmp0 |> 
  # Generate the summary stats for id vars
  mutate(skim_idvars = map(nppr_data, \(df) {
    df |> 
      select(hv001, hv002, hvidx) |> 
      skim_without_charts()
  })) |> 
  # Pool the summary stats for all nppr rounds
  select(c(ctr_name, svy_year, skim_idvars)) |> 
  unnest(cols = c(skim_idvars)) |> 
  arrange(skim_variable, svy_year) |> 
  # Group and generate the max and min values for each variable
  group_by(variable = skim_variable) |> 
  summarize(
    min_val = min(numeric.p0),
    max_val = max(numeric.p100)
  ) |> 
  # calculate the num of digits in the maximum values
  mutate(
    max_digits = nchar(as.character(max_val))
  ) |>
  # add variable labels and relocate it after variable name
  bind_cols(vlabel = c("cluster number", "household number", "Persons line number")) |>
  relocate(vlabel, .after = 1)

# Convert the tibble to flextable for easy viewing
nppr1_pre_tmp3 |>
  qflextable() |>
  align(align = "left", part = "all") |>
  autofit()

```

The above table gives the required length of the constituent ID variables to be set, so that we can correctly concatenate them to create the ID variables. The **required length of the ID variables** are given in **max_digits** column. **Note that** survey year is also a constituent ID variable of 4-digits.

## Checking Family structure variables before harmonization

Here we check the family structure related variables before harmonizing them. The variable names were collected by manually checking the full data dictionaries. Here we will check the data dictionary of these hh-level variables and focus on the variable types.

```{r}
#| label: create-dict-famstrvars
#| echo: true
#| output: false

# We check the family structure vars in all nppr datasets.
# First we create the data dictionary in nested tibble.
nppr1_pre_tmp1 <- nppr1_pre_tmp0 |>
  mutate(lookfor_famstrvars = map(nppr_data, \(df) {
    df |> 
      # select the common independent variables
      select(c(hv101, hv102, hv103, hv104, hv105)) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
nppr1_pre_tmp1

```

```{r}
#| label: tbl-dict-famstrvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of family structure vars across the nppr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
nppr1_pre_tmp2 <- nppr1_pre_tmp1 |> 
  select(c(svy_year, lookfor_famstrvars)) |> 
  unnest(cols = c(lookfor_famstrvars)) |> 
  arrange(pos, svy_year)

# Convert the tibble to flextable for easy viewing
nppr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table gives an overall snapshot of the family structure related variables. Interestingly, all the variables including age of hh members (a continuous var) are of labelled class. The relation to head and de facto resident variables have few missing values in nppr 1996. **Note that**, the three variables of interest hv101-hv102, two variables hv101 and hv103 have different number of value labels across the nppr rounds. Next, we compare the value labels of the individual variables across the nppr datasets.

### hv101 - Relationship to head

Next, we check the value labels of the relationship to the household head variable. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-hv101
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
nppr1_pre_tmp1 <- nppr1_pre_tmp0 |> 
  mutate(lookfor_hv101 = map(nppr_data, \(df) {
    df |> 
      select(hv101) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
nppr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hv101
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of relationship to head variable across the nppr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
nppr1_pre_tmp2 <- nppr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_hv101)) |> 
  unnest(cols = c(lookfor_hv101)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "nppr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "hv101", .before = 2)

# Convert the tibble to flextable for easy viewing
nppr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that the value label texts vary across the nppr rounds. To harmonize the relationship to head variable we can use the following value labels -

-   1 head
-   2 spouse
-   3 child
-   4 child-in-law
-   5 grandchild
-   6 parent
-   7 parent-in-law
-   8 sibling
-   9 others

Here, we merge the "spouse" and "co-spouse" categories into "spouse" category, and the "son/daughter" and "adopted/foster child" categories into "child" category.

### hv102 - de jure/usual resident

Next, we check the value labels of the de jure resident variable. This means if a household member is an usual resident of the household. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-hv102
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
nppr1_pre_tmp1 <- nppr1_pre_tmp0 |> 
  mutate(lookfor_hv102 = map(nppr_data, \(df) {
    df |> 
      select(hv102) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
nppr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hv102
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of the De jure resident variable across the nppr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
nppr1_pre_tmp2 <- nppr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_hv102)) |> 
  unnest(cols = c(lookfor_hv102)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "nppr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "hv102", .before = 2)

# Convert the tibble to flextable for easy viewing
nppr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that hv102 has the same value label texts and codes across the nppr rounds. Therefore, we can use this variable directly after converting to factor type.

### hv103 - de facto resident

Next, we check the value labels of the de facto resident variable. In DHS this means if a household member slept last night in the household. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-hv103
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
nppr1_pre_tmp1 <- nppr1_pre_tmp0 |> 
  mutate(lookfor_hv103 = map(nppr_data, \(df) {
    df |> 
      select(hv103) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
nppr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hv103
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of the De facto resident variable across the nppr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
nppr1_pre_tmp2 <- nppr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_hv103)) |> 
  unnest(cols = c(lookfor_hv103)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "nppr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "hv103", .before = 2)

# Convert the tibble to flextable for easy viewing
nppr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that hv103 has the same value label texts and codes across the nppr rounds. Therefore, we can use this variable directly after converting to factor type.

## START FROM HERE

TASK:

-   Handling multiple births in death scarring vars may not be necessary.
-   Preceding birth interval construction has changed with DHS-7. We could re-construct it.

TO BE CONTINUED ...
