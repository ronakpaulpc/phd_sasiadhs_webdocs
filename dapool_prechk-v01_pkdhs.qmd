---
title: "PKDHS data pooling pre-checks"
---

# Getting started

Here we show the pre-requisite code sections. Run these at the outset to avoid errors. First we load the required packages.

```{r}
#| label: load-packages
#| echo: true
#| output: false

easypackages::libraries(
  # Data i/o
  "here",                 # relative file path
  "rio",                  # file import-export
  
  # Data manipulation
  "janitor",              # data cleaning fns
  "haven",                # stata, sas, spss data io
  "labelled",             # var labelling
  "readxl",               # excel sheets
  # "scales",               # to change formats and units
  "skimr",                # quick data summary
  "broom",                # view model results
  
  # Data analysis
  "DHS.rates",            # demographic rates for dhs-like surveys
  "GeneralOaxaca",        # BO decomposition for non-linear
  "survey",               # apply survey weights
  
  # Analysis output
  "gt",
  # "modelsummary",          # output summary tables
  "gtsummary",            # output summary tables
  "flextable",            # creating tables from objects
  "officer",              # editing in office docs
  
  # R graph related packages
  "ggstats",
  "RColorBrewer",
  # "scales",
  "patchwork",
  
  # Misc packages
  "tidyverse",            # Data manipulation iron man
  "tictoc"                # Code timing
)

```

Next we turn off scientific notations.

```{r}
#| label: turn-off-scientific-notation
#| echo: true
#| output: false

options(scipen = 999)

```

Next we set the default gtsummary print engine for tables.

```{r}
#| label: set-gtsummary-default
#| echo: true
#| output: false 

theme_gtsummary_printer(print_engine = "flextable")

```

Now we set the flextable output defaults.

```{r}
#| label: set-flextable-default
#| echo: true
#| output: false 

set_flextable_defaults(
  font.size = 11,
  text.align = "left",
  big.mark = "",
  background.color = "white",
  table.layout = "autofit",
  theme_fun = theme_vanilla
)

```

# Document introduction

Here we document the variable codes and labels of variables across all the Pakistan Demographic and Health Survey (DHS) datasets. We check the variable labels and codes before running the pooling code in "daprep-v01_pkdhs.R". We pool the following Pakistan DHS surveys:

```{r}
#| label: data-import-temp
#| echo: false
#| output: false

# Here we temporarily import the tibbles for sample size table creation
# Importing the pkbr nested tibble
pkbr1_tmp_intro <- read_rds(
  file = here("website_data", "pkbr1_nest0.rds")
)
# Importing the pkir nested tibble
pkir1_tmp_intro <- read_rds(
  file = here("website_data", "pkir1_nest0.rds")
)
# Importing the pkhr nested tibble
pkhr1_tmp_intro <- read_rds(
  file = here("website_data", "pkhr1_nest0.rds")
)
# Importing the pkpr nested tibble
pkpr1_tmp_intro <- read_rds(
  file = here("website_data", "pkpr1_nest0.rds")
)

```

```{r}
#| label: tbl-detail-survey-rounds
#| echo: true
#| output: true
#| tbl-cap: "Pakistan DHS datasets and their sample size to be used for pooling"

# Creating the table of surveys to be used for pooling
pkbr1_tmp_intro |> 
  mutate(n_births = prettyNum(n_births, big.mark = ",")) |> 
  select(c(ctr_name, svy_year, n_births)) |> 
  # Join vars from pkir_tmp_intro
  left_join(
    pkir1_tmp_intro |> 
      mutate(n_women = prettyNum(n_women, big.mark = ",")) |> 
      select(c(year, n_women)),
    by = join_by(svy_year == year)
  ) |> 
  # Join vars from pkhr_tmp_intro
  left_join(
    pkhr1_tmp_intro |> 
      mutate(n_households = prettyNum(n_households, big.mark = ",")) |> 
      select(svy_year, n_households),
    by = join_by(svy_year)
  ) |> 
  # Join vars from pkpr_tmp_intro
  left_join(
    pkpr1_tmp_intro |> 
      mutate(n_persons = prettyNum(n_persons, big.mark = ",")) |> 
      select(svy_year, n_persons),
    by = join_by(svy_year)
  ) |> 
  # convert nested tibble to simple tibble
  unnest(cols = c()) |> 
  mutate(
    ccode = row_number(), 
    .before = ctr_name
  ) |> 
  # convert to flextable object
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

```{r}
#| label: just-another-chunk01
#| echo: false
#| output: false

# We remove the (.)_tmp_intro nested tibbles from the environment memory 
# as they are not required further
rm(list = c("pkbr1_tmp_intro", 
            "pkir1_tmp_intro", 
            "pkhr1_tmp_intro", 
            "pkpr1_tmp_intro"))

# Reclaim unused space
gc()

```

We use the following variables for the pooled data analysis:

-   **Dependent variable**
    -   infantd = Index child died during infancy period (0-11 months)
-   **Main Independent variable**
    -   sibsurv_nmv = Survival status of preceding child (Death scarring)
    -   binterval_3c_nmv_opp = Birth interval preceding to index child
-   **Independent variables \[CHILD LEVEL\]**
    -   cyob10y_opp = Birth cohort of index child
    -   bord_c = Birth order of index child
    -   sex_fm = Sex of index child
    -   season = Season during birth
-   **Independent variables \[MOTHER/PARENT LEVEL\]**
    -   ~~myob_opp = Birth cohort of mother~~
    -   macb_c_opp = Mother's age during birth of index child
    -   medu_opp = Mother's Level of education
    -   fedu_opp = Father's level of education
-   **Independent variables \[HOUSEHOLD LEVEL\]**
    -   religion = Religion
    -   nat_lang = Native language of respondent
    -   wi_qt_opp = Household wealth quintile
    -   ~~hhgen_2c_opp = Generations in household~~
    -   hhstruc_opp = Household structure
    -   head_sex_fm = Sex of HH head
-   **Independent variables \[COMMUNITY LEVEL\]**
    -   por = Place of residence of the household
    -   ecoreg = Ecological region

*Note: (a) Crossed names indicates variable not included.*

# Data import

We will directly import the nested tibble here. The code for dataset preparation is in the "daprep-v01_pkdhs.R" script file.

```{r}
#| label: data-import
#| echo: true
#| output: true

# Here we import the tibbles to be used for dataset checking
# Import the pkbr nested tibble
pkbr1_pre_tmp0 <- read_rds(file = here("website_data", "pkbr1_nest0.rds"))
# Import the pkhr nested tibble
pkhr1_pre_tmp0 <- read_rds(file = here("website_data", "pkhr1_nest0.rds"))
# Import the pkpr nested tibble
pkpr1_pre_tmp0 <- read_rds(file = here("website_data", "pkpr1_nest0.rds"))

```

# Pakistan BR dataset use for variable creation

## Checking the Women's weight variable before harmonization

We will check the formatting of the v005 women's weight variable before creating the pooled survey weight. For this we will use the labelled::look_for().

```{r}
#| label: create-dict-v005
#| echo: true
#| output: false

# First we create the data dictionary of v005 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v005 = map(pkbr_data, \(df) {
    df |> 
      select(v005) |> 
      look_for(details = "full") |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character() |> 
      select(-c(levels:n_na))
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v005
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v005 variable across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v005)) |> 
  select(-pos) 
# Convert and view the tibble as flextable
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The women's weight variables are in numeric class and have no missing values. However, in Pakistan DHS 2017 some observations have weight 0. These observations are from Pakistan Occupied Kashmir (POK) and Gilgit-Baltistan province. Therefore, while preparing the data we will remove POK and Gilgit-Baltistan region from all rounds of PKDHS. Find out why?? Thus, we need not reformat them while preparing the pooled survey weight. They will automatically get adjusted with the removal of the two regions.

## Checking the ID variables before harmonization

Here we check the formatting of the variables using which we will prepare the ID variables for the pooled Pakistan birth history recode (BR) dataset. We will use the following constituent variables for creating the ID variables for the pooled dataset:

```{r}
#| label: create-dict-pkbr-idvars
#| echo: true
#| output: false

# We check the var type of ID vars in all pkbr datasets.
# First we create a data dictionary of the pkbr datasets in nested tibble.
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |>
  mutate(lookfor_idvars = map(pkbr_data, \(df) {
    df |> 
      select(v001, v002, v003, bord, v021, v022, v023, v024) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-pkbr-idvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of variables to be used for ID creation across the pkbr rounds"

# Now we unnest the tibble and output the pooled data dictionary 
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_idvars)) |> 
  arrange(pos)

# Convert and view the tibble as flextable
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above we can see that v023 and v024 are of labelled class, while the rest are in numeric class. Therefore, we will check the numeric and labelled variables in different ways. **Note that** although survey year is a constituent ID variable we have not checked it. It is imperative that survey year would be a 4-digit variable.

### Numeric ID variables check

First, let's find out the required length of the numeric ID variables by checking the maximum values of the constituent ID variable across the Pakistan DHS datasets. Here we estimate the summary stats of numeric constituent variables using skim_without_charts().

```{r}
#| label: create-dict-numeric-idvars
#| echo: true
#| output: false

# Check the summary stats for ID vars using skimr in each pkbr dataset.
# First we estimate the summary stats using skim_without_charts().
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(skim_id_num = map(pkbr_data, function(df) {
    df |> 
      select(v001, v002, v003, bord, v021, v022) |> 
      skim_without_charts() |> 
      as_tibble() |> 
      select(-c(skim_type, n_missing, complete_rate)) |> 
      rename(
        variable = 1,
        mean = 2,
        sd = 3,
        min = 4,
        p25 = 5,
        p50 = 6,
        p75 = 7,
        max = 8
      )
  }))
pkbr1_pre_tmp1

```

Next, we check the summary stats of numeric variables by variable name-wise.

```{r}
#| label: tbl-dict-numeric-idvars
#| echo: true
#| output: true
#| tbl-cap: "Summary statistics of the numeric ID variables"

# Now we unnest the nested tibble so that we can compare the variable length 
# across the pkbr datasets.
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(skim_id_num)) |> 
  arrange(variable, svy_year) |> 
  # change the decimal places of selected variables
  mutate(
    mean = sprintf("%.1f", mean),
    sd = sprintf("%.1f", sd),
    p75 = sprintf("%.0f", p75)
  )
# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

Now we find out the required length of the numeric ID variables to be set, so that we can correctly concatenate them to create the ID variables. The **required length of the numeric ID variables** are given in **max_digits** column. **Note that** survey year is also a constituent ID variable of 4-digits.

```{r}
#| label: tbl-maxlen-numeric-idvars
#| echo: true
#| output: true
#| tbl-cap: "The maximum length of numeric variables to be set across the pkbr rounds for concatenating the ID variables"

# Processing the above nested tibble further
pkbr1_pre_tmp3 <- pkbr1_pre_tmp2 |> 
  group_by(variable) |> 
  # find the minimum and maximum values across surveys 
  summarize(
    min_val = min(min),
    max_val = max(max)
  ) |> 
  mutate(
    # calculate the num of digits in the maximum values
    max_digits = nchar(as.character(max_val)),
    # convert char var to factor
    variable = fct(
      variable, 
      levels = c("v001", "v002", "v003", "bord", "v021", "v022")
    )
  ) |> 
  # sort the rows by factor levels 
  arrange(variable) |> 
  # add variable labels and relocate it after variable name.
  bind_cols(vlabel = c("cluster number", "household number", 
                       "respondent's line number", "birth order", 
                       "primary sampling unit", "sample strata for se")) |> 
  relocate(vlabel, .after = 1)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp3 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

### Labelled ID variables check

First we check the labels in sub-national region variable coded as v024 across the pkbr datasets. Let's create a nested tibble of v024's value labels.

```{r}
#| label: create-dict-v024
#| echo: true
#| output: false

# Create the data dictionary for v024 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v024 = map(pkbr_data, \(df) {
    df |> 
      select(v024) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

Now we view the value labels of v024 in the table below.

```{r}
#| label: tbl-dict-v024
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v024 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v024)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |> 
  # Show the variable name in a col
  mutate(var_name = "v024", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

**NOTE:** The sub-national region var, v024 has different value labels in each survey year. It is similar for pkbr 1990 and 2006. After that the label values are different for each survey round.\
**VERD:** In this analysis, we do not use the region var in the ID var. Also we will remove the Gilgit Baltistan region in pkbr 2012 and the Gilgit Baltistan and Pakistan Occupied Kashmir region in pkbr 2017 while preparing the pooled dataset.

------------------------------------------------------------------------

Secondly, we check the labels in v023 variable that denotes the stratifications used for sampling design. First we create a nested tibble of v023's value labels.

```{r}
#| label: create-dict-v023
#| echo: true
#| output: false

# Create the data dictionary for v023 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v023 = map(pkbr_data, \(df) {
    df |> 
      select(v023) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

Now we view the value labels of v023 in the table below.

```{r}
#| label: tbl-dict-v023
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v023 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v023)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v023", .before = 2) 

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

**NOTE:** The labels of v023 are different across the survey rounds.\
**VERD:** Therefore we cannot use v023 in the ID variable preparation.

## Checking the Birth History variables before harmonization

Undoubtedly the birth history variables are important for this study objective. Therefore, we need to scrutinize all the birth history variables before using them to prepare harmonized variables for the pooled dataset.

```{r}
#| label: create-dict-bhvars
#| echo: true
#| output: false

# We check the birth history vars in all pkbr datasets.
# First we create a data dictionary in nested tibble.
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |>
  mutate(lookfor_bhvars = map(pkbr_data, \(df) {
    df |> 
      select(bidx, matches("^b[0-9]+")) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-bhvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of birth history variables across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_bhvars)) |> 
  arrange(pos)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above table we get an overall snapshot of the birth history variables. We see that the variables b1-b13 are common in all the 4 pkbr datasets. Next, we look at the labelled variables which are common across pkbr in more details. We would like to see if the value labels of the common birth history variables are similar across the pkbr datasets.

### b0 - child is twin

We check the value labels of b0 variable that denotes whether the child is twin. First we create a nested tibble of b0's value labels.

```{r}
#| label: create-dict-b0
#| echo: true
#| output: false

# Create the data dictionary for b0 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_b0 = map(pkbr_data, \(df) {
    df |> 
      select(b0) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b0
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b0 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b0)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b0", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see the value labels of b0 in the above table. We see that the value labels and codes are same across the pkbr datasets.

### b4 - sex of child

We check the value labels of b4 variable which gives the sex of the child. First we create a nested tibble of b4's value labels.

```{r}
#| label: create-dict-b4
#| echo: true
#| output: false

# Create the data dictionary for b4 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_b4 = map(pkbr_data, \(df) {
    df |> 
      select(b4) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b4
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b4 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b4)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b4", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see the value labels of b4 in the above table. The value labels and codes are similar across the pkbr datasets with minor differences in capitalization in pkbr 2012.

### b5 - child is alive

We check the value labels of b5 variable which gives the survival status of the child. First we create a nested tibble of b5's value labels.

```{r}
#| label: create-dict-b5
#| echo: true
#| output: false

# Create the data dictionary for b5 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_b5 = map(pkbr_data, \(df) {
    df |> 
      select(b5) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b5
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b5 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b5)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b5", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that the value labels and codes of survival status of child are similar across the pkbr datasets.

### b6 - age at death

We check the value labels of b6 variable which shows the age at death of children. Note that this variable has many missing values across all pkbr rounds as not all children experienced mortality throughout their lifetime. First we create a nested tibble of b6's value labels.

```{r}
#| label: create-dict-b6
#| echo: true
#| output: false

# Create the data dictionary for b5 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_b6 = map(pkbr_data, \(df) {
    df |> 
      select(b6) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b6
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b6 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b6)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b6", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that the value labels and codes of age at death of child differ among the pkbr rounds.

### b9 - child lives with whom

We check the value labels of b9 variable which gives info on who the child lives with. First we create a nested tibble of b9's value labels.

```{r}
#| label: create-dict-b9
#| echo: true
#| output: false

# Create the data dictionary for b9 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_b9 = map(pkbr_data, \(df) {
    df |> 
      select(b9) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b9
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b9 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b9)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b9", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that the value labels and codes of child lives with whom variable are similar across the pkbr datasets. Only pkbr 1990 has a different category of "\[4\] 15+ & live elsewhere".

### b10 - completeness of information

We check the value labels of b10 variable which gives the completeness of birth history information. First we create a nested tibble of b10's value labels.

```{r}
#| label: create-dict-b10
#| echo: true
#| output: false

# Create the data dictionary for b10 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_b10 = map(pkbr_data, \(df) {
    df |> 
      select(b10) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-b10
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of b10 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_b10)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "b10", .before = 2) 

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |>
  align(align = "left", part = "all") |> 
  autofit()

```

We can see in the above table that the value labels of b10 are similar across the pkbr datasets. Only pkbr 2017 has an extra category of "\[0\] month, year and day".

## Checking the Common independent variables before harmonization

Next we start documenting the common independent variables. First we will check the data dictionary of the common independent variables. Then we will check them variable wise.

```{r}
#| label: create-dict-comindvars
#| echo: true
#| output: false

# We check the common independent vars in all pkbr datasets.
# First we create the data dictionary in nested tibble.
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |>
  mutate(lookfor_comindvars = map(pkbr_data, \(df) {
    df |> 
      # select the common independent variables
      select(v106, v011, v501, v701, v025, v151, v152) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-comindvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of common independent variables across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_comindvars)) |> 
  arrange(pos)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above table we get an overall snapshot of the common independent variables. We see that all the categorical variables have the same number of value labels across the 4 pkbr datasets. **Note that** the v701 variable has few missing values in 1990 and 2017 rounds and the v152 variable has some in the the pkbr 1990 round. Interestingly, the age of household head variable (v152) is a continuous variable and has some value labels. Next, we look at the labelled variables among these common variables in more details. We would like to see if the value labels and codes of the common independent variables are similar across the pkbr datasets.

### v106 - Mother's education level

We check the value labels of v106 variable that denotes the highest education level of mother. First we create a nested tibble of v106's value labels.

```{r}
#| label: create-dict-v106
#| echo: true
#| output: false

# Create the data dictionary for v106 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v106 = map(pkbr_data, \(df) {
    df |> 
      select(v106) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v106
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v106 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v106)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v106", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can see the value labels of v106 are mostly similar across the pkbr datasets.

### v011 - Date of birth (in CMC)

The v011 variable, which has the dob of mothers in cmc, is a continuous variable. Let's check the range of these values in further details such as checking for outliers. First let's create a nested tibble of the summary statistics of v011 variable.

```{r}
#| label: create-dict-v011
#| echo: true
#| output: false

# Create the summary statistics for v011 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(skim_v011 = map(pkbr_data, \(df) {
    df |> 
      select(v011) |> 
      skim_without_charts() |> 
      as_tibble() |> 
      select(-c(skim_type, complete_rate)) |> 
      rename(
        variable = 1,
        n_miss = 2,
        mean = 3,
        sd = 4,
        min = 5,
        p25 = 6,
        p50 = 7,
        p75 = 8,
        max = 9
      )
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v011
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v011 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(skim_v011)) |> 
  # Make variable values have one decimal point 
  mutate(
    mean = sprintf("%.1f", mean),
    sd = sprintf("%.1f", sd)
  )

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

### v501 - Mother's marital status

We check the value labels of v501 variable which gives the current marital status of mother. First we create a nested tibble of v501's value labels.

```{r}
#| label: create-dict-v501
#| echo: true
#| output: false

# Create the data dictionary for v501 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v501 = map(pkbr_data, \(df) {
    df |> 
      select(v501) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v501
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v501 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v501)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v501", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

All the pkbr rounds have 6 value labels and are similar. The pkbr 1990 and 2006 rounds have a set of similar value label texts. Then pkbr 2012 and 2017 have another set of similar value labels.

### v701 - Husband/Partner's education level

We check the value labels of v701 variable which gives the mother's husband or partner's education level. First we create a nested tibble of v701's value labels.

```{r}
#| label: create-dict-v701
#| echo: true
#| output: false

# Create the data dictionary for v701 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v701 = map(pkbr_data, \(df) {
    df |> 
      select(v701) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v701
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v701 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v701)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v701", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

All the pkbr rounds have 5 value labels. The value labels and codes are similar across the pkbr rounds.

### v025 - Type of place of residence

We check the value labels of v025 variable which shows if a household belongs to rural or urban psu. First we create a nested tibble of v025's value labels.

```{r}
#| label: create-dict-v025
#| echo: true
#| output: false

# Create the data dictionary for v025 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v025 = map(pkbr_data, \(df) {
    df |> 
      select(v025) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v025
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v025 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_v025)) |> 
  unnest(cols = c(lookfor_v025)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v025", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The value labels and codes for v025 are same across the pkbr rounds.

### v151 - Sex of household head

We check the value labels of v151 variable which gives the sex of the household head. First we create a nested tibble of v151's value labels.

```{r}
#| label: create-dict-v151
#| echo: true
#| output: false

# Create the data dictionary for v151 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_v151 = map(pkbr_data, \(df) {
    df |> 
      select(v151) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v151
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v151 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v151)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v151", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The value labels and codes for v151 are same across all the pkbr rounds.

### v152 - Age of household head

Interestingly, we see v152 (a continuous variable) has value labels for all rounds. Therefore, we check the value labels of v152. First we create a nested tibble of v152's value labels.

```{r}
#| label: create-dict-v152
#| echo: true
#| output: false

# Create the data dictionary for v152 in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  filter(svy_year != 1996) |> 
  mutate(lookfor_v152 = map(pkbr_data, \(df) {
    df |> 
      select(v152) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v152
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of v152 across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_v152)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v152", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit() 

```

We can see that the value labels of v152 are mostly for missing values. However, since v152 has no missing values across the pkbr rounds except a few for the pkbr 1990 round, we need not be concerned about them.

## Checking the Social group variables before harmonization

Now we document the social group variables and then harmonize them. Upon manually checking the full data dictionaries of each pkbr dataset we find the following variables - language of questionnaire, language of interview and native language of respondent. First we will check the overall data dictionary of these social group variables. Then we will check them variable wise.

```{r}
#| label: create-dict-socgrp
#| echo: true
#| output: false

# We check the social group vars in all pkbr datasets.
# First we create the data dictionary in nested tibble.
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |>
  mutate(lookfor_socgrp = map(pkbr_data, \(df) {
    df |> 
      # select the social group variables
      select(any_of(c(
        "slang1", "slang2", "slang3", "slangq", "slangi", "slangw", "slangr", 
        "v045a", "v045b", "v045c"
      ))) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-socgrp
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of social group variables across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_socgrp)) |> 
  arrange(pos)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table gives an overall snapshot of the social group variables. All the variables are of labelled class. **Note that**, the social group variables for pkbr 1990 has few missing values. Next, we look at the variables individually for matching the value labels across the pkbr datasets.

### Language of questionnaire

Let's check the value labels of the language of questionnaire variable. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-v045a
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_lang = map(pkbr_data, \(df) {
    df |> 
      select(any_of(c("slang1", "slangq", "v045a"))) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v045a
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of language of interview variable across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_lang)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v045a", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The language of questionnaire variable has multiple value labels. However the value labels and codes differ across the pkbr rounds.

### Language of interview

Next, we check the value labels of the language of interview variable. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-v045b
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_lang = map(pkbr_data, \(df) {
    df |> 
      select(any_of(c("slang2", "slangi", "v045b"))) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v045b
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of language of interview variable across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_lang)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v045b", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The language of interview variable has multiple value labels. However the value labels and codes differ across the pkbr rounds.

### Native language of hh respondent

Next, we check the value labels of the native language of hh respondent variable. The variable names of this variable differs across the pkbr datasets. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-v045c
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_lang = map(pkbr_data, \(df) {
    df |> 
      select(any_of(c("slang3", "slangw", "slangr", "v045c"))) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-v045c
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of native language of respondent variable across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_lang)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkbr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "v045c", .before = 2)

# Convert the tibble to flextable for easy viewing
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The native language of respondent variable has multiple value labels. However the value labels and codes differ across the pkbr rounds.

## Correcting year-related variables

The year-related variables might have different formatting in each survey. Therefore, we need to check and harmonize them before appending the datasets.

```{r}
#| label: create-dict-yrvar
#| echo: true
#| output: false

# First we create the data dictionary of year-related vars in nested tibble
pkbr1_pre_tmp1 <- pkbr1_pre_tmp0 |> 
  mutate(lookfor_year = map(pkbr_data, \(df) {
    df |> 
      select(c(b2, v007, v010)) |> 
      look_for(details = "full") |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character() |> 
      select(-c(levels:n_na))
  }))
pkbr1_pre_tmp1

```

```{r}
#| label: tbl-dict-yrvar
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of year-related variables across the pkbr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
pkbr1_pre_tmp2 <- pkbr1_pre_tmp1 |> 
  select(-c(unf, pkbr_data, n_births)) |> 
  unnest(cols = c(lookfor_year)) |> 
  arrange(pos)
# Convert and view the tibble as flextable
pkbr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

We can say that the year variables have correct values, especially by looking at the year of interview variable. Only in the pkbr 1990 dataset the year values are of two-digits and we need to correct them by adding 1900. After that we use the year variables for the other rounds directly for analysis.

# Pakistan HH dataset use for variable creation

## Checking the ID variables before harmonization

Here we check the formatting of the constituent variables with which we will prepare the ID variables for the pooled Pakistan household recode (HR) dataset. We will use the following constituent variables for creating the ID variables for the pooled dataset:

```{r}
#| label: create-dict-pkhr-idvars
#| echo: true
#| output: false

# We check the var type of ID vars in all pkhr datasets.
# First we create a data dictionary of the pkhr datasets in nested tibble.
pkhr1_pre_tmp1 <- pkhr1_pre_tmp0 |>
  mutate(lookfor_idvars = map(pkhr_data, \(df) {
    df |> 
      select(hv001, hv002) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkhr1_pre_tmp1

```

```{r}
#| label: tbl-dict-pkhr-idvars
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of variables to be used for ID creation across the pkhr rounds"

# Now we unnest the tibble and output the pooled data dictionary 
pkhr1_pre_tmp2 <- pkhr1_pre_tmp1 |> 
  select(c(ctr_name, svy_year, lookfor_idvars)) |> 
  unnest(cols = c(lookfor_idvars)) |> 
  arrange(pos)

# Convert and view the tibble as flextable
pkhr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above we can see that both the hv001 and hv002 are of numeric class with no missing values. These variables can be used for preparing the ID variables after finding the maximum length of their largest value. **Note that** survey year is also a constituent ID variable of 4-digits and we need not check it.

```{r}
#| label: tbl-pkhr-idvars-maxlen
#| echo: true
#| output: true
#| tbl-cap: "The maximum length of constituent ID variables to be set across the pkhr rounds"

# We thought to process the above nested tibble further by decomposing the 
# "range" col into min and max values using separate_wider_regex().
# However, we hit a roadblock as pattern did not identify the max values in 
# some pkhr rounds correctly
pkhr1_pre_tmp3 <- pkhr1_pre_tmp0 |> 
  # Generate the summary stats for id vars
  mutate(skim_idvars = map(pkhr_data, \(df) {
    df |> 
      select(hv001, hv002) |> 
      skim_without_charts()
  })) |> 
  # Pool the summary stats for all pkhr rounds
  select(c(ctr_name, svy_year, skim_idvars)) |> 
  unnest(cols = c(skim_idvars)) |> 
  arrange(skim_variable, svy_year) |> 
  # Group and generate the max and min values for each variable
  group_by(variable = skim_variable) |> 
  summarize(
    min_val = min(numeric.p0),
    max_val = max(numeric.p100)
  ) |> 
  # calculate the num of digits in the maximum values
  mutate(
    max_digits = nchar(as.character(max_val))
  ) |>
  # add variable labels and relocate it after variable name
  bind_cols(vlabel = c("cluster number", "household number")) |>
  relocate(vlabel, .after = 1)

# Convert the tibble to flextable for easy viewing
pkhr1_pre_tmp3 |>
  qflextable() |>
  align(align = "left", part = "all") |>
  autofit()

```

The above table gives the required length of the constituent ID variables to be set, so that we can correctly concatenate them to create the ID variables. The **required length of the ID variables** are given in **max_digits** column. **Note that** survey year is also a constituent ID variable of 4-digits.

## Checking HH-level variables before harmonization

Here we check the wealth quintile variables before harmonizing them. Note in Pakistan 1990 the wealth quintile variables are provided in a separate dataset. Therefore we join those variables to the hh file before proceeding with the checking.

Upon manually checking the full data dictionaries we find the variable names. Now we will check the overall data dictionary of these hh-level variables. Then we will check their value labels variable wise.

```{r}
#| label: create-dict-hhvars
#| echo: true
#| output: false

# We check the hh-level vars in all pkhr datasets.
# First we create the data dictionary in nested tibble.
pkhr1_pre_tmp1 <- pkhr1_pre_tmp0 |>
  mutate(lookfor_hhvars = map(pkhr_data, \(df) {
    df |> 
      # select the common independent variables
      select(matches("^wlthind5$|^hv270$")) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkhr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hhvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of hh-level variables across the pkhr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
pkhr1_pre_tmp2 <- pkhr1_pre_tmp1 |> 
  select(c(svy_year, lookfor_hhvars)) |> 
  unnest(cols = c(lookfor_hhvars)) |> 
  arrange(pos, svy_year)

# Convert the tibble to flextable for easy viewing
pkhr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table gives an overall snapshot of the hh-level variables. All the variables are of labelled class and have the same number of value labels across all the pkhr datasets.

**NOTE:** The wealth quintile variable in pkbr 2006 dataset has many missing values. Upon further checking we find that the wealth quintile variable v190 in the pkbr 2006 BR and IR dataset have no missing values. 

**SOLU:** Therefore, we will use the wealth quintile variables from the BR dataset directly for the pkbr 2006. Also, in 1990 round we will merge the wealth quintile variable from pkhr to the pkbr dataset directly. 

Next, we compare the value labels of the wealth quintile variables across the pkhr datasets.

### Wealth index quintile variable

Next, we check the value labels of the household wealth quintile variable. The variable names of this variable differs across the pkbr datasets. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-wiqt
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
pkhr1_pre_tmp1 <- pkhr1_pre_tmp0 |> 
  mutate(lookfor_wiqt = map(pkhr_data, \(df) {
    df |> 
      select(matches("^wlthind5$|^hv270$")) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkhr1_pre_tmp1

```

```{r}
#| label: tbl-dict-wiqt
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of wealth quintiles across the pkhr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkhr1_pre_tmp2 <- pkhr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_wiqt)) |> 
  unnest(cols = c(lookfor_wiqt)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkhr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "Wealth index quintiles", .before = 2)

# Convert the tibble to flextable for easy viewing
pkhr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The value labels and codes are similar in the pkhr 2006, 2012 and 2017 rounds. However, the value label texts from the pkhr 1990 round is different. Therefore, we need to be mindful of this during harmonization.

# Pakistan PR dataset use for family structure variables creation

## Checking the ID variables before harmonization

Here we check the formatting of the constituent variables with which we will prepare the ID variables for the pooled Pakistan person recode (PR) dataset. We will use the following constituent variables for creating the ID variables for the pooled dataset:

```{r}
#| label: create-dict-pkpr-idvars
#| echo: true
#| output: false

# We check the var type of ID vars in all pkpr datasets.
# First we create a data dictionary of the pkpr datasets in nested tibble.
pkpr1_pre_tmp1 <- pkpr1_pre_tmp0 |>
  mutate(lookfor_idvars = map(pkpr_data, \(df) {
    df |> 
      select(hv001, hv002, hvidx) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkpr1_pre_tmp1

```

```{r}
#| label: tbl-dict-pkpr-idvars
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of variables to be used for ID creation across the pkpr rounds"

# Now we unnest the tibble and output the pooled data dictionary 
pkpr1_pre_tmp2 <- pkpr1_pre_tmp1 |> 
  select(c(ctr_name, svy_year, lookfor_idvars)) |> 
  unnest(cols = c(lookfor_idvars)) |> 
  arrange(pos)

# Convert and view the tibble as flextable
pkpr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

From the above table we can see that all the three constituent ID variables are of numeric class with no missing values. These variables can directly be used for preparing the ID variables after finding the maximum length of their largest value. **Note that** survey year is also a constituent ID variable of 4-digits and we need not check it.

```{r}
#| label: tbl-pkpr-idvars-maxlen
#| echo: true
#| output: true
#| tbl-cap: "The maximum length of constituent ID variables to be set across the pkpr rounds"

# We thought to process the above nested tibble further by decomposing the 
# "range" col into min and max values using separate_wider_regex().
# However, we hit a roadblock as pattern did not identify the max values in 
# some pkpr rounds correctly
pkpr1_pre_tmp3 <- pkpr1_pre_tmp0 |> 
  # Generate the summary stats for id vars
  mutate(skim_idvars = map(pkpr_data, \(df) {
    df |> 
      select(hv001, hv002, hvidx) |> 
      skim_without_charts()
  })) |> 
  # Pool the summary stats for all pkpr rounds
  select(c(ctr_name, svy_year, skim_idvars)) |> 
  unnest(cols = c(skim_idvars)) |> 
  arrange(skim_variable, svy_year) |> 
  # Group and generate the max and min values for each variable
  group_by(variable = skim_variable) |> 
  summarize(
    min_val = min(numeric.p0),
    max_val = max(numeric.p100)
  ) |> 
  # calculate the num of digits in the maximum values
  mutate(
    max_digits = nchar(as.character(max_val))
  ) |>
  # add variable labels and relocate it after variable name
  bind_cols(vlabel = c("cluster number", "household number", "Persons line number")) |>
  relocate(vlabel, .after = 1)

# Convert the tibble to flextable for easy viewing
pkpr1_pre_tmp3 |>
  qflextable() |>
  align(align = "left", part = "all") |>
  autofit()

```

The above table gives the required length of the constituent ID variables to be set, so that we can correctly concatenate them to create the ID variables. The **required length of the ID variables** are given in **max_digits** column. **Note that** survey year is also a constituent ID variable of 4-digits.

## Checking Family structure variables before harmonization

Here we check the family structure related variables before harmonizing them. The variable names were collected by manually checking the full data dictionaries. Here we will check the data dictionary of these hh-level variables and focus on the variable types.

```{r}
#| label: create-dict-famstrvars
#| echo: true
#| output: false

# We check the family structure vars in all pkpr datasets.
# First we create the data dictionary in nested tibble.
pkpr1_pre_tmp1 <- pkpr1_pre_tmp0 |>
  mutate(lookfor_famstrvars = map(pkpr_data, \(df) {
    df |> 
      # select the common independent variables
      select(c(hv101, hv102, hv103, hv104, hv105)) |> 
      lookfor(details = "full") |> 
      select(-c(levels:n_na)) |> 
      # For correctly viewing the range column in data dictionary
      convert_list_columns_to_character()
  }))
pkpr1_pre_tmp1

```

```{r}
#| label: tbl-dict-famstrvars
#| echo: true
#| output: true
#| fenced: true
#| tbl-cap: "Data dictionary of family structure vars across the pkpr rounds"

# Now we unnest the tibble and refine the pooled data dictionary 
pkpr1_pre_tmp2 <- pkpr1_pre_tmp1 |> 
  select(c(svy_year, lookfor_famstrvars)) |> 
  unnest(cols = c(lookfor_famstrvars)) |> 
  arrange(pos, svy_year)

# Convert the tibble to flextable for easy viewing
pkpr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table gives an overall snapshot of the family structure related variables. Interestingly, all the variables including age of hh members (a continuous variable) are of labelled class. All the family structure variables have few missing values in pkpr 1990 and 2017. **Note that**, the hv101 variable of interest have different number of value labels across the pkpr rounds. Next, we compare the value labels of the individual variables across the pkpr datasets.

### hv101 - Relationship to head

Next, we check the value labels of the relationship to the household head variable. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-hv101
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
pkpr1_pre_tmp1 <- pkpr1_pre_tmp0 |> 
  mutate(lookfor_hv101 = map(pkpr_data, \(df) {
    df |> 
      select(hv101) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkpr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hv101
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of relationship to head variable across the pkpr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkpr1_pre_tmp2 <- pkpr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_hv101)) |> 
  unnest(cols = c(lookfor_hv101)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkpr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "hv101", .before = 2)

# Convert the tibble to flextable for easy viewing
pkpr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that the value label texts vary across the pkpr rounds. To harmonize the relationship to head variable we can use the following value labels -

-   1 head
-   2 spouse
-   3 child
-   4 child-in-law
-   5 grandchild
-   6 parent
-   7 parent-in-law
-   8 sibling
-   9 others

Here, we merge the "spouse" and "co-spouse" categories into "spouse" category, and the "son/daughter" and "adopted/foster child" categories into "child" category.

### hv102 - de jure/usual resident

Next, we check the value labels of the de jure resident variable. This means if a household member is an usual resident of the household. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-hv102
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
pkpr1_pre_tmp1 <- pkpr1_pre_tmp0 |> 
  mutate(lookfor_hv102 = map(pkpr_data, \(df) {
    df |> 
      select(hv102) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkpr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hv102
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of the De jure resident variable across the pkpr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkpr1_pre_tmp2 <- pkpr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_hv102)) |> 
  unnest(cols = c(lookfor_hv102)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkpr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "hv102", .before = 2)

# Convert the tibble to flextable for easy viewing
pkpr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that hv102 has the same value label texts and codes across the pkpr rounds. Therefore, we can use this variable directly after converting to factor type.

### hv103 - de facto resident

Next, we check the value labels of the de facto resident variable. In DHS this means if a household member slept last night in the household. First we create a nested tibble of the value labels.

```{r}
#| label: create-dict-hv103
#| echo: true
#| output: false

# Create the data dictionary in nested tibble
pkpr1_pre_tmp1 <- pkpr1_pre_tmp0 |> 
  mutate(lookfor_hv103 = map(pkpr_data, \(df) {
    df |> 
      select(hv103) |> 
      look_for() |> 
      lookfor_to_long_format() |> 
      select(value_labels)
  }))
pkpr1_pre_tmp1

```

```{r}
#| label: tbl-dict-hv103
#| echo: true
#| output: true
#| tbl-cap: "Data dictionary of the De facto resident variable across the pkpr rounds"

# Now we unnest the tibble and refine the pooled data dictionary
pkpr1_pre_tmp2 <- pkpr1_pre_tmp1 |> 
  # First we select the required cols and unnest()
  select(c(ctr_name, svy_year, lookfor_hv103)) |> 
  unnest(cols = c(lookfor_hv103)) |> 
  # Next we make the num of value labels same across each round
  mutate(label_num = parse_number(value_labels)) |> 
  complete(ctr_name, svy_year, label_num) |>
  # Next we create col of value labels for each survey round
  pivot_wider(
    names_from = svy_year, 
    values_from = value_labels,
    names_prefix = "pkpr_"
  ) |>
  # Show the variable name in a col
  mutate(var_name = "hv103", .before = 2)

# Convert the tibble to flextable for easy viewing
pkpr1_pre_tmp2 |> 
  qflextable() |> 
  align(align = "left", part = "all") |> 
  autofit()

```

The above table shows that hv103 has the same value label texts and codes across the pkpr rounds. Therefore, we can use this variable directly after converting to factor type.

## START FROM HERE

TASK:

-   Handling multiple births in death scarring vars may not be necessary.
-   Preceding birth interval construction has changed with DHS-7. We could re-construct it.

TO BE CONTINUED ...

